---
title: 奇怪的操作系统相关习题～4-21
date: 2020/03/28 16:24:14
abbrlink: 9a5136f172523006
categories:
- 杂七杂八
tags:
- 操作系统
- 习题
- 奇怪
- 相关
---
# 操作系统作业
## 操作系统在计算机系统分层中处于哪个层次？它与上下层是怎样衔接的？
### 计算机系统的分层：
1. 第1级是微程序机器层，这是一个实在的硬件层，它由机器硬件直接执行微指令。
2. 第2级是传统机器语言，它也是一个实际的机器层，它由微程序解释机器指令系统。
3. 第3级是操作系统层，它由操作系统程序实现。操作系统程序由机器指令和广义指令组成，这些广义指令是为了扩展机器功能而设置的，它是由操作系统定义和解释的软件指令，所以这一层也称为混合层。
4. 第4级是汇编语言层，它为用户提供一种符号化的语言，借此可编写汇编语言源程序。这一层由汇编语言支持和执行。
5. 第5级是高级语言层，它是面向用户的，为方便用户编写应用程序而设置的。该层有高级语言编译支持和执行。
6. 在高级语言层之上，还可以有应用层，由解决实际问题和应用问题的处理程序组成，如文字处理软件、数据库软件、多媒体软件和办公自动化软件等。

下层是上层的基础，上层是下层的扩展。

### 怎样衔接？
操作系统是是连接硬件和软件的中间桥梁，作为用户与计算机硬件系统之间的接口，它通过系统调用、命令（命令行和图形界面）的命令方式；作为计算机系统资源的管理者，它管理处理器、存储器、IO设备以及信息（程序与数据）；它实现了对计算机资源的抽象，在裸机上覆盖上一层 I/O 设备管理软件，又在第一层软件上再覆盖上一层用于文件的管理软件（第二个层次的抽象），再覆盖一层面向用户的窗口软件。

## 请结合实例，说明如何理解操作系统是资源管理器？如何理解操作系统是资源管理机？
计算机系统的运行需要软件和硬件的协同工作，将系统中的各个硬件功能部件和软件功能模块看成系统资源，操作系统就是这些资源的管理器。如何有效合理地使用各种资源、为用户提供最佳的服务是操作系统的主要工作内容。在资源管理中将包括以下工作内容：
1. 跟踪记录资源使用情况：在多道任务系统中，系统资源要满足多道任务的需要，但一个任务对资源的需要可能并不是连续的，这就需要对资源使用情况进行跟踪和记录，了解当前资源状态或剩余情况，以满足任务对资源的请求。
2. 分配或回收资源：在条件满足的情况下将资源分配给请求的任务，分配后要记录当前资源剩余情况和状态，以备下一次的分配；根据任务完成的情况适时地回收系统资源，保证新进程的请求。
3. 提高资源的利用率：在操作系统的管理下力图使系统资源得到合理、高效的使用。
4. 协调多个进程对资源请求的冲突：当少量资源为多个请求服务时，会产生资源使用冲突，这时操作系统需要分析请求进程的特性，对资源使用做出决策，协调各进程合理地使用资源。

### 结合实例
把操作系统看作向应用程序提供基本抽象的概念，是一种自顶向下的观点。按照另一种自底向上的观点，操作系统则用来管理一个复杂系统的各个部分。现代计算机包含处理器、存储器、时钟、磁盘、鼠标、网络接口、打印机以及许多其他设备。从这个角度看，操作系统的任务是在相互竞争的程序之间有序地控制对处理器、存储器以及其他I/O接口设备的分配。

现代操作系统允许同时在内存中运行多道程序。假设在一台计算机上运行的三个程序试图同时在同一台打印机上输出计算结果，那么开始的几行可能是程序1的输出，接着几行是程序2的输出，然后又是程序3的输出等，最终结果将是一团糟。采用将打印结果送到磁盘上缓冲区的方法，操作系统可以把潜在的混乱有序化。在一个程序结束后，操作系统可以将暂存在磁盘上的文件送到打印机输出，同时其他程序可以继续产生更多的输出结果，很明显，这些程序的输出还没有真正送至打印机。

当一个计算机（或网络）有多个用户时，管理和保护存储器、I/O设备以及其他资源的需求变得强烈起来，因为用户间可能会互相干扰。另外，用户通常不仅共享硬件，还要共享信息（文件、数据库等）。简而言之，操作系统的这种观点认为，操作系统的主要任务是记录哪个程序在使用什么资源，对资源请求进行分配，评估使用代价，并且为不同的程序和用户调解互相冲突的资源请求。

资源管理包括用以下两种不同方式实现多路复用（共享）资源：在时间上复用和在空间上复用。当一种资源在时间上复用时，不同的程序或用户轮流使用它。先是第一个获得资源的使用，然后下一个，以此类推。例如，若在系统中只有一个CPU，而多个程序需要在该CPU上运行，操作系统则首先把该CPU分配给某个程序，在它运行了足够长的时间之后，另一个程序得到CPU，然后是下一个，如此进行下去，最终，轮到第一个程序再次运行。至于资源是如何实现时间复用的—谁应该是下一个以及运行多长时间等—则是操作系统的任务。还有一个有关时间复用的例子是打印机的共享。当多个打印作业在一台打印机上排队等待打印时，必须决定将轮到打印的是哪个作业。

另一类复用是空间复用。每个客户都得到资源的一部分，从而取代了客户排队。例如，通常在若干运行程序之间分割内存，这样每一个运行程序都可同时入驻内存（例如，为了轮流使用CPU）。假设有足够的内存可以存放多个程序，那么在内存中同时存放若干个程序的效率，比把所有内存都分给一个程序的效率要高得多，特别是，如果一个程序只需要整个内存的一小部分，结果更是这样。当然，如此的做法会引起公平、保护等问题，这有赖于操作系统解决它们。有关空间复用的其他资源还有磁盘。在许多系统中，一个磁盘同时为许多用户保存文件。分配磁盘空间并记录谁正在使用哪个磁盘块，是操作系统的典型任务。

## 进程与程序的区别与联系是什么？请尽力描述操作系统是怎样实现进程的。
### 进程和程序区别和联系表现在以下方面：
1. 程序只是一组指令的有序集合，它本身没有任何运行的含义，它只是一个静态的实体。而进程则不同，它是程序在某个数据集上的执行。进程是一个动态的实体，它有自己的生命周期。它因创建而产生，因调度而运行，因等待资源或事件而被处于等待状态，因完成任务而被撤消。反映了一个程序在一定的数据集上运行的全部动态过程。
2. 进程和程序并不是一一对应的，一个程序执行在不同的数据集上就成为不同的进程，可以用进程控制块来唯一地标识每个进程。而这一点正是程序无法做到的，由于程序没有和数据产生直接的联系，既使是执行不同的数据的程序，他们的指令的集合依然是一样的，所以无法唯一地标识出这些运行于不同数据集上的程序。一般来说，一个进程肯定有一个与之对应的程序，而且只有一个。而一个程序有可能没有与之对应的进程(因为它没有执行),也有可能有多个进程与之对应(运行在几个不同的数据集上)。
3. 进程还具有并发性和交往性，这也与程序的封闭性不同。

### 如何实现进程
#### 进程包含以下内容：
1. 程序的代码
2. 程序的数据
3. CPU寄存器的值，包括通用寄存器，程序计数器
4. 堆(heap)是用来保存进程运行时动态分配的内存空间
5. 栈(stack)有两个用途，1保存运行的上下文信息。2在函数调用时保存被调用函数的形参或者局部变量
6. 进程所占用的一组系统资源，如打开的文件


#### PCB
进程在操作系统内用进程控制块（process control block,PCB)来表示，PCB石金成存在的证明。PCB包含了进程状态、程序计数器、cpu寄存器、cpu调度信息、内存管理信息、记账信息、I/O状态信息等信息。

**PCB内容：**
- 进程状态（Process state）： 状态可包括新的，就绪，运行，等待，终止等。
- 程序计数器（Program counter） ： 计数器表示进程要执行的下个指令的地址。
- CPU寄存器（CPU registers）：与程序计数器一起，这些寄存器的状态信息在出现中断时也需要保存，以便进程以后能正确的执行。
- CPU调度信息（CPU scheduling information）：这类信息包括进程优先级、调度队列指针和其他调度参数。
- 内存管理信息（Memory-management information）：根据内存系统，这类信息包括基址和界限寄存器的值，页表或段表。
- 记账信息（Accounting information）：这类信息包括CPU时间、实际使用时间、时间界限、记账数据、作业或进程数量等。
- I/O状态信息（I/O status information）：这类信息包含分配给进程的I/O设备列表、打开的文件列表等。

#### 进程状态管理
进程的状态模型图有三状态，五状态，七状态三种，下面主要来看一下五状态模型，如下所示：
{% asset_img 8869373-13838275d57feca0.png %}

- 新的（NEW）：进程正在被创建
- 运行（RUNNING）：指令正在被执行
- 等待（WAIT）：进程等待某个事件的发生（如I/O完成或受到信号）
- 就绪 （READY）：进程已经准备好，只需要分配CPU就可以执行（等待CPU）
- 终止（TERMINAL）：进程完成执行

三状态模型是五状态模型的简化版，七状态模型划分的更为详细，如下图所示：
{% asset_img 8869373-abf58f2acc1866af.png %}

- 就绪挂起：是指进程被对换到辅存时的就绪状态，是不能被直接调度的状态，只有当主存中没有就绪态进程，或者是挂起就绪态进程具有更高的优先级，系统将把挂起就绪态进程调回主存并转换为就绪。
- 阻塞挂起：是指进程对换到辅存时的阻塞状态，一旦等待的事件产生便进入阻塞挂起状态。

#### 进程调度
多道程序设计的目的就是无论何时都有进程执行，从而使CPU利用率达到最大。而如何使CPU无论何时都有进程执行， 该执行哪一个进程就是进程调度要处理的内容。简单地说，进程调度的目的就是为了更好的使用资源。

##### 调度队列
1. 作业队列：进程进入系统时被加入到作业队列中，该队列包含系统中所有进程。
2. 就绪队列：驻留在内存中等待运行的程序保存在就绪队列中，该队列常用链表来实现，其头节点指向链表的第一个和最后一个PCB块的指针。每个PCB包括一个指向就绪队列的下一个PCB的指针域。
3. 设备队列: 操作系统也有其他队列。等待特定IO设备的进程列表称为设备队列。每个设备都有自己的设备队列。

新进程开始处于就绪队列，它就在就绪队列中等待直到被选中执行或被派遣。当进程分配到CPU执行时，可能发生：

1. 进程发出一个IO请求，并放到IO队列中。
2. 进程创建新的子进程，并等待其结束
3. 进程由于中断而强制释放cpu，并被放回到就绪队列。

##### 调度程序
进程会在各种调度队列之间迁移，为了调度，操作系统必须按某种方式从这些队列中选择进程。进程的选择是由相应的调度程序（scheduler）来执行的。调度程序可以分为以下几种：

1. 短程调度（short-term scheduler），又称CPU调度。从已经就绪的进程中选取一个放在CPU上执行，即使进程从ready状态变到running状态。
2. 中程调度 （medium-term scheduler），将进程从内存移到外存上，对应进程状态是从ready/waiting状态转为挂起状态。
3. 长程调度（long-term scheduler），又称作业调度（job scheduler）。从输入井中选取一个进程加载到内存中去执行，对应的进程状态是从new状态变到ready状态。

##### 上下文切换
中断使CPU从当前任务改变为运行内核子程序。当发生一个中断时，系统需要保存当前运行在CPU中进程的上下文，从而能在其处理完后恢复上下文。进程的上下文用PCB来表示。通常通过执行一个状态保存（state save）来保存cpu当前状态，之后执行一个状态恢复（state restore）重新开始运行。将CPU切换到另一进程需要保存当前状态并恢复另一进程状态，这叫做上下文切换（context switch）。当发生上下文切换时，内核会将旧进程的状态保存在PCB中，然后装入经调度要执行的并已保存的新进程的上下文。

#### 进程操作
1. 进程创建
2. 进程终止
3. 孤儿进程与僵尸进程

## 进程之间为什么要同步？为什么要互斥？
### 为什么要同步
系统中多个进程中发生的事件存在某种时序的关系，需要相互合作，共同完成一项任务。例如，假设进程A产生数据，而进程B打印数据，则B在打印之前必须等A产生数据。

**典型例子：生产者-消费者问题**

### 为什么要互斥
由于操作系统各进程需要使用共享资源，而这些资源需要排他性使用，各进程之间竞争使用这些资源，例如：一个文件的读写问题。一个文件在被读的时候，不能同时进行写的操作。
